## 程序、进程、线程相关知识
### 程序、进程、线程
- **程序**：由源代码生成的可执行应用。
- **进程**：一个正在运行的程序可以看做一个进程，进程拥有独立运行所需要的全部资源，是**资源分配的基本单位**。
- **线程**：程序中独立运行的代码段。是**调度运行的基本单位**。

一个进程是由一或多个线程组成，进程只负责资源的调度和分配，线程才是程序真正的执行单元，负责代码的执行。

### 进程控制块PCB
描述和控制进程的运行，系统为每个进程定义了一个数据结构——进程控制块（PCB）。是进程重要的组成部分，它记录了操作系统所需的、用于描述进程的当前状态和控制进程的全部信息。 

操作系统就是根据进程的PCB来感知进程的存在，并依此对进程进行管理和控制。 PCB是进程存在的唯一标识。

PCB主要包括：进程标识信息、处理机状态（PSW）、进程调度信息（状态、优先级等）、进程控制信息 （程序和数据地址、进程同步和通信机制等）。

### 进程上下文
进程执行时需要操作系统为其设置相应的执行环境，如系统堆栈、地址映像寄存器、程序计数器、程序状态字、打开文件表以及相关通用寄存器等。 所以，把进程的物理实体与支持进程执行的**物理环境**合称为进程上下文。

### 进程上下文切换
进程上下文切换发生在不同的进程之间而不是同一个进程内。
    进程上下文切换分成三个步骤：
    （1） 把被切换进程的相关信息保存到有关存储区，例如该进程的PCB中。
    （2） 操作系统中的调度和资源分配程序执行，选取新的进程。
    （3） 将被选中进程的原来保存的正文部分从有关存储区中取出，并送至寄存器与堆栈中,激活被选中进程执行。 

### 单线程与多线程
- **单线程**
每个正在运行的程序（即进程），至少包括一个线程，这个线程叫主线程。
主线程在程序启动时被创建，用于执行main函数。只有一个主线程的程序，称作单线程程序。
主线程负责执行程序的所有代码（UI展现以及刷新，网络请求，本地存储等等）。这些代码只能顺序执行，无法并发执行。
- **多线程**
拥有多个线程的程序，称作多线程程序。
iOS允许用户自己开辟新的线程，相对于主线程来讲，这些线程，称为子线程。可以根据需要开辟若干子线程。
子线程和主线程都是独立的运行单元，各自的执行互不影响，因此能够并发执行。

### 进程间通信方式
进程间通信（IPC，Interprocess communication）是一组编程接口，让程序员能够协调不同的进程，使之能在一个操作系统里同时运行，并相互传递、交换信息。这使得一个程序能够在同一时间里处理许多用户的要求。因为即使只有一个用户发出要求，也可能导致一个操作系统中多个进程的运行，进程之间必须互相通话。IPC接口就提供了这种可能性。每个IPC方法均有它自己的优点和局限性，一般，对于单个程序而言使用所有的IPC方法是不常见的。
IPC方法包括管道（PIPE）、消息排队、旗语、共用内存以及套接字（Socket）。
  - 管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
  - 有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
  - 信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
  - 消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
  - 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
  - 共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
  - 套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。

### 线程之间的通信方式
 ##### 锁机制：包括互斥锁、条件变量、读写锁
- 互斥锁提供了以排他方式防止数据结构被并发修改的方法。
- 读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
- 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
##### 信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量
##### 信号机制(Signal)：类似进程间的信号处理
    线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。

### 多进程与多线程对比
![多进程与多线程对比](http://upload-images.jianshu.io/upload_images/6214896-3e673a13a3c22398.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


### 什么时候用多线程?什么时候用多进程？
1）需要频繁创建销毁的优先用线程
原因请看上面的对比。
这种原则最常见的应用就是Web服务器了，来一个连接建立一个线程，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的
2）需要进行大量计算的优先使用线程
所谓大量计算，当然就是要耗费很多CPU，切换频繁了，这种情况下线程是最合适的。
这种原则最常见的是图像处理、算法处理。
3）强相关的处理用线程，弱相关的处理用进程
什么叫强相关、弱相关？理论上很难定义，给个简单的例子就明白了。
一般的Server需要完成如下任务：消息收发、消息处理。“消息收发”和“消息处理”就是弱相关的任务，而“消息处理”里面可能又分为“消息解码”、“业务处理”，这两个任务相对来说相关性就要强多了。因此“消息收发”和“消息处理”可以分进程设计，“消息解码”、“业务处理”可以分线程设计。
当然这种划分方式不是一成不变的，也可以根据实际情况进行调整。
4）可能要扩展到多机分布的用进程，多核分布的用线程
原因请看上面对比。
5）都满足需求的情况下，用你最熟悉、最拿手的方式
至于“数据共享、同步”、“编程、调试”、“可靠性”这几个维度的所谓的“复杂、简单”应该怎么取舍，我只能说：没有明确的选择方法。但我可以告诉你一个选择原则：如果多进程和多线程都能够满足要求，那么选择你最熟悉、最拿手的那个。

### 进程状态转换图

![转换图](http://upload-images.jianshu.io/upload_images/6214896-ddda922a3d921d7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
1）运行：当一个进程在处理机上运行时，则称该进程处于运行状态。处于此状态的进程的数目小于等于处理器的数目，对于单处理机系统，处于运行状态的进程只有一个。在没有其他进程可以执行时（如所有进程都在阻塞状态），通常会自动执行系统的空闲进程。

（2）就绪：当一个进程获得了除处理机以外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。就绪进程可以按多个优先级来划分队列。例如，当一个进程由于时间片用完而进入就绪状态时，排入低优先级队列；当进程由I／O操作完成而进入就绪状态时，排入高优先级队列。

（3）阻塞：也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I/O而等待I/O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。
参考于：http://blog.csdn.net/hyqsong/article/details/51592992

### 线程状态转换图

![image.png](http://upload-images.jianshu.io/upload_images/6214896-eb24e9283b2ea744.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

参考于：http://www.cnblogs.com/bhlsheji/p/5099362.html

### 相关题目
1. 以下多线程对int型变量x的操作，哪几个需要进行同步： 　　　　
A. x=y;      B. x++;    C. ++x;    D. x=1;
答案是ＡＢＣ，y的写入与x读y要同步，x++和++x都要知道x之前的值，所以也要同步。

2. 多线程中栈与堆是公有的还是私有的

　　　　A：栈公有, 堆私有
　　　　B：栈公有，堆公有
　　　　C：栈私有, 堆公有
　　　　D：栈私有，堆私有
　
答案是C,栈一般存放局部变量，而程序员一般自己申请和释放堆中的数据。

3. 两个线程并发执行（代码段都是ThreadProc)，问两个线程都结束后，a取值范围。
```
int a = 0;//global
void ThreadProc()
{
  　　　　 for(inti = 1; i <= 50; i++)
        　　  a += 1;
}
```
当两线程串行时，结果最大为100，当某个线程运行结束，而此时另外一个线程刚取出0，还未计算时，结果最小为50。
参考于：http://www.cnblogs.com/wuchanming/p/3992395.html?utm_source=tuicool&utm_medium=referral

4. 进程之间的通信方式IPC：管道、共享内存、套接字、信号量、消息排队

5. 线程之间的通信方式：锁机制、信号量机制、信号机制
     
        线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。

6. 线程进程定义
进程是资源分配的基本单位，有独立的地址空间。
线程是资源调度运行的最小单位。线程是拥有自己的局部变量和栈，线程之间共享堆。

7. 线程之间如何共享进程的资源？
它们之间共享大部分数据，使用相同的地址空间。线程是拥有自己的局部变量和栈，线程之间共享堆。并且通过共享数据（全局变量、静态变量）实现线程之间的通信。

8. 什么是线程安全？
如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。

9. 下列代码执行结果？
```
var t = true;
window.setTimeout(function (){
    t = false;
},1000);
while (t){}
alert('end');
```
万万没想到的是结果是进入死循环。这里涉及的知识点是JS的异步任务与单线程。参考知乎回答https://www.zhihu.com/question/21475411/answer/188678456
在JavaScript中任务有两种，一种是同步任务，一种是异步任务。
同步任务：各个任务按照文档定义的顺序一一推入"执行栈"中，当前一个任务执行完毕，才会开始执行下一个任务。
异步任务：各个任务推入"任务队列"中，只有在当前的所有同步任务执行完毕，才会将队列中的任务"出队"执行。（注：这里的异步任务并不一定是按照文档定义的顺序推入队列中）。
如下列所示：
```
//第一个推入队列中
setTimeout(function(){
  console.log("1");
},0);
//第三个推入队列中
setTimeout(function(){
 console.log("2");
},1000);
//第二个推入队列中
setTimeout(function(){
  console.log("3");
},0);
 //第一个推入执行栈中
console.log('4')
```
最后的执行结果是4、1、3、2，其原理就是先将同步任务推入执行栈，将异步任务推入任务队列，当执行栈中的同步任务完成之后再调用任务队列中的异步任务。
所以这里会跳过异步任务setTimeout而进入死循环。

10. 在用户空间实现线程，其最大的优点是什么？最大的缺点是什么？

答：最大的优势就是效率。不需要陷入内核来切换线程。最大的缺点是，如果一个线程阻塞，整个进程都会阻塞。

11. 一个快餐店有四类雇员：(1) 领班，接收顿客点的菜单；（2）厨师，准备饭菜；（3）打包工，将饭菜装在袋子里；（4) 收银员，将食品袋交给顾客并收钱。每个雇员可被看作一个进行通信的顺序进程。它们采用的进程间通信方式是什么？请将这个模型与UNIX中进程联系起来。

答：雇员之间通过消息传递进行通信：在该例中，消息为订单、食物和袋子。在UNIX中，该4个进程通过管道连接。

 

12. 假设有一个使用信箱的消息传递系统，当向满信箱发消息或从空信箱收消息时，进程都不会阻塞，相反，会得到一个错误代码。进程响应错误代码的处理方式为一遍一遍地重试，直到成功为止。这种方式会导致竞争条件吗？

答：它不会导致竞争条件（不会丢失任何东西），不过它是完全的忙等待。