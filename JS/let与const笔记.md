## let与const笔记

### let
1. let用于声明变量，它所声明的变量只在let命令所在的代码块内有效。let命令适合用作for循环的计数器。
2. let命令不存在变量提升。var命令会出现变量提升的现象，即变量可以在声明前使用，值为undefined。但let命令声明的变量必需在声明后使用。
3. 不允许重复声明
Let不允许在相同作用域内，重复声明同一个变量。
4. 暂时性死区：只要块级作用域内存在let命令，它所声明的变量就绑定这个区域，不再受外部影响。
     
下面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。

暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

```
var tmp = 123
if (true) {
	tmp = 'abc'; // ReferenceError
	let tmp;
}
```

##### let使用
```
var a = [];
for (var i = 0; i < 10; i++) {
	a[i] = function () {     
		console.log(i);   
	}; 
} 
a[6](); // 10
```
上面段代码，数组a中每个都输出10。不是期望的结果。

```
var a = [];
for (let i = 0; i < 10; i++) {
	a[i] = function () {     
		console.log(i);   
	}; 
} 
a[6](); // 10
```
使用Let命令可以解决，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。

### 块级作用域
ES5只有全局作用域和函数作用域，没有块级作用域，会存在很多问题。

1. 内层变量可能会覆盖外层变量
2. 用来计数的循环变量泄露为全局变量

Let实际上为js新增了块级作用域。es6允许块级作用域的任意嵌套；内层作用域可以定义外层作用域的相同变量名。

在es5中，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。

Es6引入了块级作用域，明确允许在块级作用域中声明函数，但是在块级作用域之外不能引用该函数。

### const命令
const声明一个只读的常量，一旦声明，常量的值就不能改变，且必须在声明的时候就初始化。const的作用域与let命令相同：只在声明所在的块级作用域内有效。且const命令声明的常量也不会提升，同样存在暂时性死区，只能在声明的位置后面使用，并且不能重复声明。

对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。